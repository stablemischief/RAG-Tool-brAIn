{
  "id": "rag_tool_standalone",
  "code": "async function rag_tool_standalone(params, userSettings) {\n    var query = params.query;\n    var matchCount = params.match_count || 10;\n    var includeFullDocument = params.include_full_document || false;\n    var ragToolApiUrl = userSettings.ragToolApiUrl || 'http://localhost:8000';\n\n    try {\n        // Ensure URL is properly formatted\n        if (!ragToolApiUrl.startsWith('http')) {\n            ragToolApiUrl = 'http://' + ragToolApiUrl;\n        }\n        if (ragToolApiUrl.endsWith('/')) {\n            ragToolApiUrl = ragToolApiUrl.slice(0, -1);\n        }\n\n        // Use the RAG Tool Standalone API for search\n        var searchUrl = ragToolApiUrl + '/api/search';\n        \n        // Create form data for the POST request\n        var formData = new URLSearchParams();\n        formData.append('query', query);\n        formData.append('limit', matchCount.toString());\n        \n        var searchResponse = await fetch(searchUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Accept': 'application/json'\n            },\n            body: formData.toString()\n        });\n\n        if (!searchResponse.ok) {\n            var searchError = await searchResponse.text();\n            return '‚ùå **RAG Tool Search Error**\\n\\n' +\n                   'Status: ' + searchResponse.status + '\\n' +\n                   'Error: ' + searchError + '\\n\\n' +\n                   'üí° Make sure your RAG Tool Standalone server is running at ' + ragToolApiUrl + '\\n' +\n                   'Check that the search endpoint is accessible and documents are loaded.';\n        }\n\n        var response = await searchResponse.json();\n        var results = response.results || [];\n\n        // Format results based on mode\n        var output = '## üîç RAG Tool Standalone Search Results\\n\\n';\n        output += '**Query:** \"' + query + '\"\\n';\n        output += '**Mode:** ' + (includeFullDocument ? 'Full Document Retrieval' : 'Chunk Search') + '\\n';\n        output += '**Results Found:** ' + results.length + '\\n';\n        output += '**Search Timestamp:** ' + (response.timestamp || new Date().toISOString()) + '\\n\\n';\n        \n        if (!results || results.length === 0) {\n            output += '### ‚ùå No Matching Documents Found\\n\\n';\n            output += 'This could mean:\\n';\n            output += '- No semantically similar content exists in the knowledge base\\n';\n            output += '- Try rephrasing your query with different terms\\n';\n            output += '- The knowledge base may need to be updated with relevant content\\n';\n            output += '- Check that Google Drive monitoring is active and processing files\\n';\n            return output;\n        }\n\n        if (includeFullDocument) {\n            // Get unique file IDs from the top results\n            var fileIds = [];\n            var seenFiles = {};\n            \n            for (var i = 0; i < Math.min(results.length, 3); i++) {\n                var doc = results[i];\n                if (doc.metadata && doc.metadata.file_id && !seenFiles[doc.metadata.file_id]) {\n                    fileIds.push({\n                        file_id: doc.metadata.file_id,\n                        file_title: doc.metadata.file_title || doc.metadata.filename || 'Unknown Document',\n                        relevance: doc.similarity ? (doc.similarity * 100).toFixed(1) + '%' : 'N/A'\n                    });\n                    seenFiles[doc.metadata.file_id] = true;\n                }\n            }\n            \n            output += '### üìã Complete Document(s) Retrieved\\n\\n';\n            \n            for (var j = 0; j < fileIds.length; j++) {\n                var fileInfo = fileIds[j];\n                output += '---\\n\\n';\n                output += '## üìÑ ' + fileInfo.file_title + '\\n\\n';\n                output += '**Relevance:** ' + fileInfo.relevance + '\\n';\n                output += '**File ID:** ' + fileInfo.file_id + '\\n\\n';\n                \n                // For now, use the current results as full document content\n                // Future enhancement: implement file_id filtering in the API\n                var allChunks = results.filter(function(result) {\n                    return result.metadata && result.metadata.file_id === fileInfo.file_id;\n                });\n                    \n                    if (allChunks && allChunks.length > 0) {\n                        output += '**Complete Document Content** (' + allChunks.length + ' chunks):\\n\\n';\n                        \n                        // Sort chunks by chunk_index to maintain order\n                        allChunks.sort(function(a, b) {\n                            var aIndex = (a.metadata && a.metadata.chunk_index) ? parseInt(a.metadata.chunk_index) : 0;\n                            var bIndex = (b.metadata && b.metadata.chunk_index) ? parseInt(b.metadata.chunk_index) : 0;\n                            return aIndex - bIndex;\n                        });\n                        \n                        // FIXED: No artificial limits - retrieve ALL chunks for complete documents\n                        var chunkLimit = allChunks.length;\n                        \n                        // Combine chunks\n                        var fullContent = '';\n                        for (var k = 0; k < chunkLimit; k++) {\n                            if (allChunks[k].content) {\n                                fullContent += allChunks[k].content.trim() + ' ';\n                            }\n                        }\n                        \n                        output += fullContent.trim() + '\\n\\n';\n                        \n                        // Add source link if available\n                        if (allChunks[0].metadata && (allChunks[0].metadata.file_url || allChunks[0].metadata.url)) {\n                            var sourceUrl = allChunks[0].metadata.file_url || allChunks[0].metadata.url;\n                            output += '**Source:** [View Original Document](' + sourceUrl + ')\\n\\n';\n                        }\n                    } else {\n                        output += '*No chunks found for this document in current results*\\n\\n';\n                    }\n            }\n        } else {\n            // Standard chunk-based results\n            output += '---\\n\\n';\n            \n            for (var i = 0; i < results.length; i++) {\n                var doc = results[i];\n                var similarity = doc.similarity ? (doc.similarity * 100).toFixed(1) : 'N/A';\n                var title = 'Document ' + (doc.id || i+1);\n                var chunkInfo = '';\n                \n                if (doc.metadata) {\n                    if (doc.metadata.file_title || doc.metadata.filename) {\n                        title = doc.metadata.file_title || doc.metadata.filename;\n                    }\n                    if (doc.metadata.chunk_index !== undefined) {\n                        chunkInfo = ' (Chunk #' + doc.metadata.chunk_index + ')';\n                    }\n                }\n\n                output += '### üìÑ ' + (i + 1) + '. ' + title + chunkInfo + '\\n\\n';\n                output += '**Relevance:** ' + similarity + '%\\n';\n                \n                if (doc.metadata) {\n                    if (doc.metadata.file_url || doc.metadata.url) {\n                        var sourceUrl = doc.metadata.file_url || doc.metadata.url;\n                        output += '**Source:** [View Document](' + sourceUrl + ')\\n';\n                    }\n                    if (doc.metadata.file_id) {\n                        output += '**File ID:** ' + doc.metadata.file_id + '\\n';\n                    }\n                    if (doc.metadata.last_modified) {\n                        output += '**Last Modified:** ' + doc.metadata.last_modified + '\\n';\n                    }\n                }\n                \n                output += '\\n**Content:**\\n';\n                if (doc.content) {\n                    var content = doc.content.replace(/\\s+/g, ' ').trim();\n                    var maxLength = 500;\n                    if (content.length > maxLength) {\n                        content = content.substring(0, maxLength) + '...';\n                    }\n                    output += '> ' + content + '\\n\\n';\n                } else {\n                    output += '> *No content available*\\n\\n';\n                }\n                \n                if (i < results.length - 1) {\n                    output += '---\\n\\n';\n                }\n            }\n        }\n        \n        // Add helpful tips\n        output += '\\n### üí° Usage Tips\\n\\n';\n        if (!includeFullDocument) {\n            output += '- Set `include_full_document: true` to retrieve complete documents instead of chunks\\n';\n        }\n        output += '- Increase `match_count` (up to 50) for more comprehensive results\\n';\n        output += '- Use specific terms for better semantic matching\\n';\n        output += '- Check the RAG Tool dashboard for system status and document count\\n';\n\n        // Add system info\n        output += '\\n### üõ†Ô∏è System Info\\n\\n';\n        output += '- **RAG Tool API:** ' + ragToolApiUrl + '\\n';\n        output += '- **Embedding Model:** text-embedding-3-small (1536 dimensions)\\n';\n        output += '- **Vector Search:** PostgreSQL + pgvector\\n';\n\n        return output;\n\n    } catch (error) {\n        return '## üí• Plugin Error\\n\\n' + \n               '**Error Type:** ' + error.name + '\\n' +\n               '**Message:** ' + error.message + '\\n\\n' + \n               '**Stack Trace:**\\n```\\n' + (error.stack || 'No stack trace available') + '\\n```\\n\\n' +\n               '**Troubleshooting:**\\n' +\n               '1. Ensure RAG Tool Standalone is running at ' + ragToolApiUrl + '\\n' +\n               '2. Check that the dashboard shows \"Database: Connected\" and \"Google Drive: Connected\"\\n' +\n               '3. Verify documents have been processed (check dashboard statistics)\\n' +\n               '4. Try accessing ' + ragToolApiUrl + '/health in your browser\\n' +\n               '5. Check the RAG Tool logs for any processing errors';\n    }\n}",
  "uuid": "rag-tool-standalone-search-fixed",
  "emoji": "üîç",
  "title": "RAG Tool Standalone Search (FIXED)",
  "syncedAt": null,
  "deletedAt": null,
  "mcpDetails": null,
  "openaiSpec": {
    "name": "rag_tool_standalone",
    "parameters": {
      "type": "object",
      "required": [
        "query"
      ],
      "properties": {
        "query": {
          "type": "string",
          "description": "Your search query for finding relevant content in the knowledge base"
        },
        "match_count": {
          "type": "integer",
          "description": "Number of chunks to return (default: 10, max: 50)",
          "default": 10,
          "minimum": 1,
          "maximum": 50
        },
        "include_full_document": {
          "type": "boolean",
          "description": "If true, retrieves complete documents by combining all chunks (default: false)",
          "default": false
        }
      }
    },
    "description": "Search your RAG Tool Standalone knowledge base with semantic vector search. Can retrieve either relevant chunks or complete documents."
  },
  "outputType": "respond_to_ai",
  "oauthConfig": null,
  "userSettings": [
    {
      "name": "ragToolApiUrl",
      "label": "RAG Tool API URL",
      "required": false,
      "description": "URL of your RAG Tool Standalone server (default: http://localhost:8000)",
      "default": "http://localhost:8000"
    }
  ],
  "overviewMarkdown": "## RAG Tool Standalone Search Plugin (FIXED)\n\n### üöÄ Enhanced Capabilities\n\n**Two Search Modes:**\n1. **Chunk Search** (default) - Returns relevant document chunks\n2. **Full Document** - Reconstructs complete documents from all chunks\n\n### üìã Complete Document Retrieval\n\nWhen `include_full_document: true`:\n- Finds relevant documents using vector search\n- Retrieves ALL chunks for those documents\n- Reconstructs the complete original document\n- **NO ARTIFICIAL LIMITS** - Gets 100% of chunks regardless of file type\n- Maintains proper chunk ordering\n- Perfect for templates, full articles, or complete files\n\n### üéØ Enhanced Chunk Search\n\nWhen `include_full_document: false`:\n- Returns up to 50 relevant chunks\n- Higher match_count for comprehensive coverage\n- Great for finding specific information across documents\n\n### üìñ Example Usage\n\n**For Complete Documents:**\n```\nQuery: \"partnership agreement\"\ninclude_full_document: true\nmatch_count: 5\n```\n\n**For Template Files:**\n```\nQuery: \"welcome email template\"\ninclude_full_document: true\nmatch_count: 3\n```\n\n**For Comprehensive Search:**\n```\nQuery: \"project requirements\"\ninclude_full_document: false\nmatch_count: 25\n```\n\n### ‚öôÔ∏è Setup Requirements\n\n1. **RAG Tool Standalone** server running (default: localhost:8000)\n2. Google Drive integration active and processing documents\n3. Database populated with documents from your Drive folder\n\n### ‚ú® Key Features (FIXED Version)\n\n- **Complete Template Files** with ALL content - no artificial 50-chunk limit\n- **Full Document Recreation** from all available chunks\n- **Comprehensive Information Gathering** across documents\n- **No Content Limitations** on retrieval\n- **Enhanced Image Handling** - Images filtered to prevent vector corruption\n- **Preserved Hyperlinks** - Links maintained during processing\n- **Zero Database Config** - Uses your RAG Tool API directly\n- **Smart Chunking** - 400-character chunks (preserved exactly from original)\n- **Vector Search** - OpenAI text-embedding-3-small (1536 dimensions)\n- **File Type Support** - PDF, DOCX, TXT, HTML, CSV, XLS, XLSX, PPTX, MD, Google Docs\n\n### üîß Troubleshooting\n\n- **No Results?** Check RAG Tool dashboard for document count and processing status\n- **Connection Error?** Verify RAG Tool server is running at the configured URL\n- **Empty Knowledge Base?** Ensure Google Drive monitoring is active and has processed files\n- **Incomplete Documents?** Make sure to set `include_full_document: true` for full content\n\n### üõ†Ô∏è Technical Details\n\n- **Embedding Model:** OpenAI text-embedding-3-small\n- **Vector Database:** PostgreSQL + pgvector\n- **API Endpoint:** `/api/search` with semantic similarity\n- **Response Format:** Structured JSON with metadata and similarity scores\n- **Processing:** Enhanced markdown conversion with image filtering",
  "authenticationType": "AUTH_TYPE_NONE",
  "implementationType": "javascript",
  "dynamicContextEndpoints": [],
  "sharedOAuthConnectionID": null
}